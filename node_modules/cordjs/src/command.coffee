fs = require 'fs'
util = require 'util'
fsExtra = require 'fs.extra'
path = require 'path'
walk = require 'walk'
{spawn, exec}  = require 'child_process'

publicDir = 'public'
targetDir = 'target'
sources   = []
countFiles = null

exports.run = ->
  fsExtra.rmrf targetDir, (err) ->
    exec "mkdir -p #{path.join(targetDir)}", ->
      countFiles = 0
      fs.realpath publicDir, (err, source) ->
        syncFiles source, path.normalize(source), ->
          exec "coffee -bc -o #{targetDir} #{publicDir}"
          exec "sass --update #{publicDir}:#{targetDir}"
          timeLog "Synchronized #{ countFiles } files"

# Synchronize files
syncFiles = (source, base, callback) ->
  fs.stat source, (err, stats) ->
    return syncFile source, base if stats.isFile()

    walker = walk.walk source
    walker.on 'directory', (root, stat, next) ->
      source = path.join root, stat.name
      return next() if hidden source
      watchDir source, base
      next()

    walker.on 'file', (root, stat, next) ->
      source = path.join root, stat.name
      return next() if hidden source
      syncFile source, base, ->
        countFiles++
        next()

    walker.on 'end', ->
      callback?()

# Synchronize target-file with the source
syncFile = (source, base, callback, onlyWatch = false) ->
  sources.push source     if !onlyWatch
  watchFile source, base  if !onlyWatch
  switch path.extname source
    when ".coffee", ".scss", ".sass"
      return callback()
    else
      copyFile source, base, (err) -> callback?()

# Copy file to targetPath
copyFile = (source, base, callback) ->
  filePath = outputPath source, base
  fileDir  = path.dirname filePath

  copyHelper = () ->
    fs.stat source, (err, stat) ->
      callback? err if err
      util.pump fs.createReadStream(source), fs.createWriteStream(filePath), (err) ->
        callback? err if err
        fs.utimes filePath, stat.atime, stat.mtime, callback

  exists fileDir, (itExists) ->
    if itExists then copyHelper() else exec "mkdir -p #{fileDir}", copyHelper

# Watch a source file using `fs.watch`, recompiling it every
# time the file is updated.
watchFile = (source, base) ->

  prevStats = null
  syncTimeout = null

  watchErr = (e) ->
    if e.code is 'ENOENT'
      return if sources.indexOf(source) is -1
      try
        rewatch()
        sync()
      catch e
        removeSource source, base, yes
    else throw e

  sync = ->
    clearTimeout syncTimeout
    syncTimeout = wait 25, ->
      fs.stat source, (err, stats) ->
        return watchErr err if err
        return rewatch() if prevStats and stats.size is prevStats.size and
        stats.mtime.getTime() is prevStats.mtime.getTime()
        prevStats = stats
        syncFile source, base, () ->
          timeLog "update file #{ source }"
          rewatch()
        , yes

  try
    watcher = fs.watch source, sync
  catch e
    watchErr e

  rewatch = ->
    watcher?.close()
    watcher = fs.watch source, sync

# Watch a directory of files for new adds
watchDir = (source, base) ->
#  console.log 'watchDir: ', source
  readdirTimeout = null
  try
#    console.log 'source: ', source
    watcher = fs.watch source, ->
      console.log 'watcher: ', source
      clearTimeout readdirTimeout
      readdirTimeout = wait 25, ->
        fs.readdir source, (err, files) ->
          if err
            console.log 'erro: ', err, ', cource: ', source
            throw err unless err.code is 'ENOENT'
            watcher.close()
            console.log 'removeDir:', source
            return unwatchDir source, base
          for file in files
            file = path.join source, file
            continue if sources.some (s) -> s.indexOf(file) >= 0
            console.log 'syncFiles: ', file, ', base: ', base
            sources.push file
            syncFiles file, base
  catch e
    throw e unless e.code is 'ENOENT'

# Unwatch and remove directory
unwatchDir = (source, base) ->
  prevSources = sources[..]
  toRemove = (file for file in sources when file.indexOf(source) >= 0)
  removeSource file, base, yes for file in toRemove
  return unless sources.some (s, i) -> prevSources[i] isnt s

# Remove source from targetPath
removeSource = (source, base, remove) ->
  index = sources.indexOf source
  sources.splice index, 1
  if remove
    outPath = outputPath source, base
    exists outPath, (itExists) ->
      if itExists
        fs.unlink outPath, (err) ->
          throw err if err and err.code isnt 'ENOENT'
          timeLog "removed #{source}"

# Get output path
outputPath = (source, base) ->
  filename  = path.basename source
  srcDir    = path.dirname source
  baseDir   = if base is '.' then srcDir else srcDir.substring base.length
  dir       = path.join targetDir, baseDir
  path.join dir, filename

# Convenience for cleaner setTimeouts
wait = (milliseconds, func) -> setTimeout func, milliseconds

exists    = fs.exists or path.exists
hidden = (file) -> /\/\.|~$/.test(file) or /^\.|~$/.test file
timeLog = (message) ->
  console.log "#{(new Date).toLocaleTimeString()} - #{message}"

printLine = (line) -> process.stdout.write line + '\n'
printWarn = (line) -> process.stderr.write line + '\n'

