fs = require 'fs'
util = require 'util'
fsExtra = require 'fs.extra'
path = require 'path'
walk = require 'walk'
{spawn, exec}  = require 'child_process'


publicDir = 'pubTest2'
targetDir = 'target2'
sources   = []

exports.run = ->
  fsExtra.rmrf targetDir, (err) ->
  #    console.log 'path.normalize source: ', fs.realpathSync publicDir
    exec "mkdir -p #{path.join(targetDir)}", ->
      fs.realpath publicDir, (err, source) ->
      #        fs.realpath targetDir, (err, rdst) ->
        syncFiles source, path.normalize(source), ->
          exec "coffee -bc -o #{targetDir} #{publicDir}"
#          coffee = spawn 'coffee', ["-bc", "-o", "#{targetDir}", "#{publicDir}"]
#              console.log 'sources: ', sources
#              coffee.stdout.on 'data', (data) ->
#                  console.log 'stdout: ' + data
#              coffee.stderr.on 'data', (data) ->
#                console.log 'stderr: ' + data
#              coffee.on 'exit', (code) ->

syncFiles = (source, base, callback) ->
  console.log callback
  console.log 'startWalk: ', source
  #  if fs.
  fs.stat source, (err, stats) ->
    if stats.isFile()
    #      source = path.join root, stat.name
    #      sources.push source
    #      return next() if path.extname(source) is '.coffee'
    #      copyFile source, base, (err) -> next()
      syncFile source, base

      return
    walker = walk.walk source
    walker.on 'directory', (root, stat, next) ->
      source = path.join root, stat.name
      #    console.log 'walk dir: ', source
      #    mkdirp outputPath(source, base), stat.mode, next
      #      watchDir source, base
      next()
    walker.on 'file', (root, stat, next) ->
      source = path.join root, stat.name
      syncFile source, base, next
    walker.on 'end', ->
    #      console.log 'walk end: ', source
      callback?()

syncFile = (source, base, callback, onlyWatch = false) ->
  sources.push source     if !onlyWatch
  watchFile source, base  if !onlyWatch
  return callback() if path.extname(source) is '.coffee'
  copyFile source, base, (err) -> callback?()


copyFile = (source, base, callback) ->
  filePath = outputPath source, base
  fileDir  = path.dirname filePath

  copyHelper = () ->
    fs.stat source, (err, stat) ->
      callback? err if err
      util.pump fs.createReadStream(source), fs.createWriteStream(filePath), (err) ->
        callback? err if err
        fs.utimes filePath, stat.atime, stat.mtime, callback

  exists fileDir, (itExists) ->
    if itExists then copyHelper() else exec "mkdir -p #{fileDir}", copyHelper

# Watch a source file using `fs.watch`, recompiling it every
# time the file is updated.
watchFile = (source, base) ->

  prevStats = null
  syncTimeout = null

  watchErr = (e) ->
    if e.code is 'ENOENT'
      return if sources.indexOf(source) is -1
      try
        rewatch()
        sync()
      catch e
        removeSource source, base, yes
    else throw e

  sync = ->
    clearTimeout syncTimeout
    syncTimeout = wait 25, ->
      fs.stat source, (err, stats) ->
        return watchErr err if err
        return rewatch() if prevStats and stats.size is prevStats.size and
        stats.mtime.getTime() is prevStats.mtime.getTime()
        prevStats = stats
        syncFile source, base, () ->
          timeLog "update file #{ source }"
          rewatch()
        , yes

  try
    watcher = fs.watch source, sync
  catch e
    watchErr e

  rewatch = ->
    watcher?.close()
    watcher = fs.watch source, sync


watchDir = (source, base) ->
  console.log 'watchDir: ', source
  readdirTimeout = null
  try
    watcher = fs.watch source, ->
      console.log 'watcher: ', source
      clearTimeout readdirTimeout
      readdirTimeout = wait 25, ->
      #        console.log 'readdir: ', source
        fs.readdir source, (err, files) ->
          if err
            console.log 'erro: ', err, ', cource: ', source
            throw err unless err.code is 'ENOENT'
            watcher.close()
            console.log 'removeDir:', source
            return unwatchDir source, base
          #          console.log 'each: ', files, ', cource: ', source
          for file in files #when not hidden(file)
            file = path.join source, file
            continue if sources.some (s) -> s.indexOf(file) >= 0
            console.log 'syncFiles: ', file, ', base: ', base
            sources.push file
            syncFiles file, base
  catch e
  #    console.log 'watcherError: ', source, ', error: ', e
    throw e unless e.code is 'ENOENT'

unwatchDir = (source, base) ->
  prevSources = sources[..]
  toRemove = (file for file in sources when file.indexOf(source) >= 0)
  removeSource file, base, yes for file in toRemove
  #  console.log 'file ro remove: ', file, yes for file in toRemove
  return unless sources.some (s, i) -> prevSources[i] isnt s

removeSource = (source, base, removeJs) ->
  index = sources.indexOf source
  sources.splice index, 1
  if removeJs #and not opts.join
    jsPath = outputPath source, base
    #    console.log 'path to remove: ', jsPath
    exists jsPath, (itExists) ->
      if itExists
        fs.unlink jsPath, (err) ->
          throw err if err and err.code isnt 'ENOENT'
          timeLog "removed #{source}"

outputPath = (source, base) ->
  filename  = path.basename source
  srcDir    = path.dirname source
  baseDir   = if base is '.' then srcDir else srcDir.substring base.length
  dir       = path.join targetDir, baseDir
  path.join dir, filename

wait = (milliseconds, func) -> setTimeout func, milliseconds
exists    = fs.exists or path.exists

timeLog = (message) ->
  console.log "#{(new Date).toLocaleTimeString()} - #{message}"

printLine = (line) -> process.stdout.write line + '\n'
printWarn = (line) -> process.stderr.write line + '\n'

