// Generated by CoffeeScript 1.3.3
var EmptyArguments, OptionsList, copyFile, countFiles, exec, exists, fs, fsExtra, hidden, options, optparse, outputPath, parseOptions, path, printLine, printWarn, publicDir, removeSource, restartServer, server, sources, spawn, syncFile, syncFiles, targetDir, timeLog, timerRestartServer, unwatchDir, usage, util, wait, walk, watchDir, watchFile, _ref;

fs = require('fs');

fsExtra = require('fs.extra');

util = require('util');

path = require('path');

walk = require('walk');

optparse = require('./optparse');

_ref = require('child_process'), spawn = _ref.spawn, exec = _ref.exec;

publicDir = 'public';

targetDir = 'target';

options = {};

sources = [];

countFiles = null;

server = null;

timerRestartServer = null;

EmptyArguments = 'Usage: cordjs [options]';

OptionsList = [['-a', '--autorestart', 'autorestart server'], ['-d', '--dev', 'development mode - copy all files to the targetDir'], ['-h', '--help', 'display this help message'], ['-s', '--server', 'start server'], ['-w', '--watch', 'watch scripts for changes and rerun commands']];

exports.run = function() {
  parseOptions();
  if (options.help) {
    return usage();
  }
  return fsExtra.rmrf(targetDir, function(err) {
    return exec("mkdir -p " + (path.join(targetDir)), function() {
      countFiles = 0;
      return fs.realpath(publicDir, function(err, source) {
        return syncFiles(source, path.normalize(source), function() {
          return exec("coffee -bc -o " + targetDir + " " + publicDir, function() {
            exec("sass --update " + publicDir + ":" + targetDir);
            timeLog("Synchronized " + countFiles + " files");
            if (options.server) {
              return fs.realpath(targetDir, function(err, source) {
                return server = require("" + source + "/bundles/cord/core/nodeInit");
              });
            }
          });
        });
      });
    });
  });
};

syncFiles = function(source, base, callback) {
  return fs.stat(source, function(err, stats) {
    var walker;
    if (stats.isFile()) {
      return syncFile(source, base);
    }
    walker = walk.walk(source);
    walker.on('directory', function(root, stat, next) {
      source = path.join(root, stat.name);
      if (hidden(source)) {
        return next();
      }
      if (options.watch) {
        watchDir(source, base);
      }
      return next();
    });
    walker.on('file', function(root, stat, next) {
      source = path.join(root, stat.name);
      if (hidden(source)) {
        return next();
      }
      return syncFile(source, base, function() {
        countFiles++;
        return next();
      });
    });
    return walker.on('end', function() {
      return typeof callback === "function" ? callback() : void 0;
    });
  });
};

syncFile = function(source, base, callback, onlyWatch) {
  var extname;
  if (onlyWatch == null) {
    onlyWatch = false;
  }
  if (!onlyWatch) {
    sources.push(source);
  }
  if (!onlyWatch && options.watch) {
    watchFile(source, base);
  }
  if (onlyWatch) {
    restartServer();
  }
  extname = path.extname(source);
  switch (extname) {
    case ".coffee":
    case ".scss":
    case ".sass":
      if (extname === ".coffee" && onlyWatch) {
        return exec("coffee -bc -o " + (path.dirname(outputPath(source, base))) + " " + source, function() {
          timeLog("Compile CoffeeScript " + source);
          return typeof callback === "function" ? callback() : void 0;
        });
      } else if (extname === (".scss" || ".sass") && onlyWatch) {
        return exec("sass --update " + (path.dirname(outputPath(source, base))) + ":" + source, function() {
          timeLog("Compile Saas " + source);
          return typeof callback === "function" ? callback() : void 0;
        });
      } else {
        return typeof callback === "function" ? callback() : void 0;
      }
      break;
    default:
      if (options.dev) {
        if (onlyWatch) {
          timeLog("update file " + source);
        }
        return copyFile(source, base, function(err) {
          return typeof callback === "function" ? callback() : void 0;
        });
      } else {
        countFiles--;
        return typeof callback === "function" ? callback() : void 0;
      }
  }
};

restartServer = function() {
  if (!options.autorestart) {
    return;
  }
  clearTimeout(timerRestartServer);
  return timerRestartServer = wait(200, function() {
    return typeof server.restartServer === "function" ? server.restartServer() : void 0;
  });
};

copyFile = function(source, base, callback) {
  var copyHelper, fileDir, filePath;
  filePath = outputPath(source, base);
  fileDir = path.dirname(filePath);
  copyHelper = function() {
    return fs.stat(source, function(err, stat) {
      if (err) {
        if (typeof callback === "function") {
          callback(err);
        }
      }
      return util.pump(fs.createReadStream(source), fs.createWriteStream(filePath), function(err) {
        if (err) {
          if (typeof callback === "function") {
            callback(err);
          }
        }
        return fs.utimes(filePath, stat.atime, stat.mtime, callback);
      });
    });
  };
  return exists(fileDir, function(itExists) {
    if (itExists) {
      return copyHelper();
    } else {
      return exec("mkdir -p " + fileDir, copyHelper);
    }
  });
};

watchFile = function(source, base) {
  var prevStats, rewatch, sync, syncTimeout, watchErr, watcher;
  prevStats = null;
  syncTimeout = null;
  watchErr = function(e) {
    if (e.code === 'ENOENT') {
      if (sources.indexOf(source) === -1) {
        return;
      }
      try {
        rewatch();
        return sync();
      } catch (e) {
        return removeSource(source, base, true);
      }
    } else {
      throw e;
    }
  };
  sync = function() {
    clearTimeout(syncTimeout);
    return syncTimeout = wait(25, function() {
      return fs.stat(source, function(err, stats) {
        if (err) {
          return watchErr(err);
        }
        if (prevStats && stats.size === prevStats.size && stats.mtime.getTime() === prevStats.mtime.getTime()) {
          return rewatch();
        }
        prevStats = stats;
        return syncFile(source, base, function() {
          return rewatch();
        }, true);
      });
    });
  };
  try {
    watcher = fs.watch(source, sync);
  } catch (e) {
    watchErr(e);
  }
  return rewatch = function() {
    if (watcher != null) {
      watcher.close();
    }
    return watcher = fs.watch(source, sync);
  };
};

watchDir = function(source, base) {
  var readdirTimeout, watcher;
  readdirTimeout = null;
  try {
    return watcher = fs.watch(source, function() {
      clearTimeout(readdirTimeout);
      return readdirTimeout = wait(25, function() {
        return fs.readdir(source, function(err, files) {
          var file, _i, _len, _results;
          if (err) {
            if (err.code !== 'ENOENT') {
              throw err;
            }
            watcher.close();
            return unwatchDir(source, base);
          }
          _results = [];
          for (_i = 0, _len = files.length; _i < _len; _i++) {
            file = files[_i];
            file = path.join(source, file);
            if (sources.some(function(s) {
              return s.indexOf(file) >= 0;
            })) {
              continue;
            }
            sources.push(file);
            _results.push(syncFiles(file, base));
          }
          return _results;
        });
      });
    });
  } catch (e) {
    if (e.code !== 'ENOENT') {
      throw e;
    }
  }
};

unwatchDir = function(source, base) {
  var file, prevSources, toRemove, _i, _len;
  prevSources = sources.slice(0);
  toRemove = (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = sources.length; _i < _len; _i++) {
      file = sources[_i];
      if (file.indexOf(source) >= 0) {
        _results.push(file);
      }
    }
    return _results;
  })();
  for (_i = 0, _len = toRemove.length; _i < _len; _i++) {
    file = toRemove[_i];
    removeSource(file, base, true);
  }
  if (!sources.some(function(s, i) {
    return prevSources[i] !== s;
  })) {

  }
};

removeSource = function(source, base, remove) {
  var index, outPath;
  index = sources.indexOf(source);
  sources.splice(index, 1);
  if (remove) {
    outPath = outputPath(source, base);
    return exists(outPath, function(itExists) {
      if (itExists) {
        return fs.unlink(outPath, function(err) {
          if (err && err.code !== 'ENOENT') {
            throw err;
          }
          return timeLog("removed " + source);
        });
      }
    });
  }
};

outputPath = function(source, base) {
  var baseDir, dir, filename, srcDir;
  filename = path.basename(source);
  srcDir = path.dirname(source);
  baseDir = base === '.' ? srcDir : srcDir.substring(base.length);
  dir = path.join(targetDir, baseDir);
  return path.join(dir, filename);
};

parseOptions = function() {
  var o, optionParser;
  optionParser = new optparse.OptionParser(OptionsList, EmptyArguments);
  o = options = optionParser.parse(process.argv.slice(2));
  if (options.autorestart) {
    options.server = options.watch = true;
  }
};

usage = function() {
  return printLine((new optparse.OptionParser(OptionsList, EmptyArguments)).help());
};

wait = function(milliseconds, func) {
  return setTimeout(func, milliseconds);
};

exists = fs.exists || path.exists;

hidden = function(file) {
  return /\/\.|~$/.test(file) || /^\.|~$/.test(file);
};

timeLog = function(message) {
  return console.log("" + ((new Date).toLocaleTimeString()) + " - " + message);
};

printLine = function(line) {
  return process.stdout.write(line + '\n');
};

printWarn = function(line) {
  return process.stderr.write(line + '\n');
};
